---
layout: post
title: "[SpringBoot] JUnit으로 TEST 작성하기 "
date: 2023-12-03 14:05:00 +0900
categories: TIL
---

## 테스트 코드를 작성하는 이유

- 개발 과정에서 문제를 미리 발견할 수 있다.
- 리팩토링의 리스크가 줄어든다
- 애플리케이션을 가동해서 직접 테스트하는 것보다 테스트를 빠르게 진행할 수 있다.
- 하나의 명세 문서로서의 기능을 수행한다.
- 코드가 작성된 목적을 명확하게 표현할 수 있으며, 불필요한 내용이 추가되는 것을 방지한다.

## 단위 테스트와 통합 테스트

### 단위 테스트

단위 테스트는 테스트 대상의 범위를 기준으로 가장 작은 단위의 테스트 방식이다. 대체로 메서드 단위를 호출해 의도한 결과값이 나오는지 확인하는 수준으로 테스트를 진행한다. 단위 테스트는 비용이 적게 들기 때문에 테스트 피드백을 빠르게 받을 수 있다.

### 통합 테스트

통합 테스트는 모듈을 통합하는 과정에서의 호환성 등을 포함해 애플리케이션이 정상적으로 동작하는지 확인하기 위해 수행하는 테스트 방식이다. 데이터베이스나 네트워크와 같은 외부 요인들을 포함하고 테스트를 진행한다. 테스트를 수행할 때마다 모든 컴포넌트가 동작해야 하기 때문에 테스트 비용이 커지는 단점이 있다.

## 어노테이션

### @WebMvcTest

웹에서 사용되는 요청과 응답에 대한 테스트를 수행할 수 있다. 대상 클래스만 로드해 테스트를 수행하며, 만약 대상 클래스를 추가하지 않으면 @Controller, @RestController, @ControllerAdvice 등의 컨트롤러 관련 빈 객체가 모두 로드된다. @SpringBootTest보다 가볍게 테스트하기 위해 사용된다. 일반적으로 @WebMvcTest를 사용한 테스트는 Slice테스트라고 부른다. 슬라이스 테스트는 단위 테스트와 통합 테스트의 중간 개념으로 이해하면 되는데, 레이어드 아키텍쳐를 기준으로 각 레이어별로 나누어 테스트를 진행한다는 의미이다. 단위 테스트를 수행하기 위해서는 모든 외부 요인을 차단하고 테스트를 진행해야 하지만 컨트롤러는 개념상 웹과 맞닿은 레이어로서 외부 요인을 차단하고 테스트하면 의미가 없기 때문에 슬라이스 테스트를 진행하는 경우가 많다.

### @MookBean

실제 빈 객체가 아닌 Mock객체를 생성해서 주입하는 역할을 수행한다. @MockBean이 선언된 객체는 실제 객체가 아니기 때문에 실제 행위를 수행하지 않는다.

### @Test

테스트 코드가 포함돼 있다고 선언하는 어노테이션이며, JUnit Jupiter에서는 이 어노테이션을 감지해서 테스트 계획에 포함시킨다.

### @DisplayName

테스트 메서드 이름이 복잡해서 가독성이 떨어질 경우 이 어노테이션을 통해 테스트에 대한 표현을 정의할 수 있다.

JUnit 테스트

```java
	@Test
	void getCityName() {
		final CityFilterDto cityFilterDto=new CityFilterDto("서울","대한민국", "한국어");
		final String cityName=cityFilterDto.getCityName();
		assertEquals("서울", cityName);
	}
```

성공
![성공](https://github.com/pingu2017/comment/assets/115390100/b07c1fbb-c97c-4934-a817-ad922ab3e41c)

실패
![실패](https://github.com/pingu2017/comment/assets/115390100/ac5ecfef-b8f6-44b7-bb50-b3cf4f3a345e)
